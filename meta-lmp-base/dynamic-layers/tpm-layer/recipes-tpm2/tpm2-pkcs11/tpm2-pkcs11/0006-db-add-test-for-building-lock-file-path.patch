From 3c75be6f597a1dbf11b78f5e612647d1b2449985 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?P=C3=A9ter=20V=C3=A1g=C3=A1ny?= <pevagany@gmail.com>
Date: Thu, 23 Feb 2023 17:24:58 +0200
Subject: [PATCH] db: add test for building lock file path
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Make sure to create correct paths and respect PKCS11_SQL_LOCK env var.

Upstream-Status: Backport [https://github.com/tpm2-software/tpm2-pkcs11/commit/98876b388c185781afa346cc9e124c8265dacd5f]

Signed-off-by: Péter Vágány <pevagany@gmail.com>
Signed-off-by: Jose Quaresma <jose.quaresma@foundries.io>
---
 src/lib/db.c        | 13 +++++++++++--
 src/lib/db.h        |  1 +
 test/unit/test_db.c | 45 ++++++++++++++++++++++++++++++++++++++++++++-
 3 files changed, 56 insertions(+), 3 deletions(-)

diff --git a/src/lib/db.c b/src/lib/db.c
index 8532904..d7792ea 100644
--- a/src/lib/db.c
+++ b/src/lib/db.c
@@ -2387,7 +2387,7 @@ static CK_RV db_create(char *path, size_t len) {
     return db_for_path(path, len, db_create_handler);
 }
 
-DEBUG_VISIBILITY FILE *take_lock(const char *path, char *lockpath) {
+DEBUG_VISIBILITY int get_lock_path(const char *path, char *lockpath) {
 
     unsigned l;
 
@@ -2405,7 +2405,7 @@ DEBUG_VISIBILITY FILE *take_lock(const char *path, char *lockpath) {
         }
         if ((lenv_lock + 1 + strlen(path) + strlen(".lock")) >= PATH_MAX) {
             LOGE("Lock file path would be longer than PATH_MAX");
-            return NULL;
+            return SQLITE_ERROR;
         }
         strncpy(lockpath, env_lock, PATH_MAX-1);
         strcat(lockpath, "/");
@@ -2424,6 +2424,15 @@ DEBUG_VISIBILITY FILE *take_lock(const char *path, char *lockpath) {
     }
     if (l >= PATH_MAX) {
         LOGE("Lock file path is longer than PATH_MAX");
+        return SQLITE_ERROR;
+    }
+
+    return SQLITE_OK;
+}
+
+DEBUG_VISIBILITY FILE *take_lock(const char *path, char *lockpath) {
+
+    if (get_lock_path(path, lockpath) != SQLITE_OK) {
         return NULL;
     }
 
diff --git a/src/lib/db.h b/src/lib/db.h
index 9653c16..52b7851 100644
--- a/src/lib/db.h
+++ b/src/lib/db.h
@@ -92,6 +92,7 @@ int init_pobject(unsigned pid, pobject *pobj, tpm_ctx *tpm);
 int __real_init_pobject(unsigned pid, pobject *pobj, tpm_ctx *tpm);
 int init_sealobjects(unsigned tokid, sealobject *sealobj);
 int __real_init_sealobjects(unsigned tokid, sealobject *sealobj);
+int get_lock_path(const char *path, char *lockpath);
 FILE *take_lock(const char *path, char *lockpath);
 #endif
 
diff --git a/test/unit/test_db.c b/test/unit/test_db.c
index a3e3f0d..00e0739 100644
--- a/test/unit/test_db.c
+++ b/test/unit/test_db.c
@@ -1,6 +1,7 @@
 /* SPDX-License-Identifier: BSD-2-Clause */
 
 #include <errno.h>
+#include <limits.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <stddef.h>
@@ -2838,6 +2839,47 @@ static void test_db_add_token_sqlite3_step_2_fail(void **state) {
     assert_int_equal(rv, CKR_GENERAL_ERROR);
 }
 
+static void test_db_get_lock_path(void **state) {
+    UNUSED(state);
+
+    const char *db_path = "/etc/tpm2_pkcs11/tpm2_pkcs11.sqlite3";
+    char lock_path[PATH_MAX];
+
+    memset(lock_path, 0, sizeof lock_path);
+    unsetenv("PKCS11_SQL_LOCK");
+    assert_int_equal(get_lock_path(db_path, lock_path), SQLITE_OK);
+    assert_string_equal(lock_path, "/etc/tpm2_pkcs11/tpm2_pkcs11.sqlite3.lock");
+
+    memset(lock_path, 0, sizeof lock_path);
+    setenv("PKCS11_SQL_LOCK", "", 1);
+    assert_int_equal(get_lock_path(db_path, lock_path), SQLITE_OK);
+    assert_string_equal(lock_path, "/etc/tpm2_pkcs11/tpm2_pkcs11.sqlite3.lock");
+
+    memset(lock_path, 0, sizeof lock_path);
+    setenv("PKCS11_SQL_LOCK", "/tmp", 1);
+    assert_int_equal(get_lock_path(db_path, lock_path), SQLITE_OK);
+    assert_string_equal(lock_path, "/tmp/_etc_tpm2_pkcs11_tpm2_pkcs11.sqlite3.lock");
+
+    memset(lock_path, 0, sizeof lock_path);
+    setenv("PKCS11_SQL_LOCK", "/tmp/", 1);
+    assert_int_equal(get_lock_path(db_path, lock_path), SQLITE_OK);
+    assert_string_equal(lock_path, "/tmp/_etc_tpm2_pkcs11_tpm2_pkcs11.sqlite3.lock");
+
+    char long_path[PATH_MAX];
+    memset(long_path, 'l', sizeof long_path);
+    long_path[PATH_MAX - 1] = '\0';
+
+    memset(lock_path, 0, sizeof lock_path);
+    setenv("PKCS11_SQL_LOCK", long_path, 1);
+    assert_int_equal(get_lock_path(db_path, lock_path), SQLITE_ERROR);
+
+    memset(lock_path, 0, sizeof lock_path);
+    unsetenv("PKCS11_SQL_LOCK");
+    assert_int_equal(get_lock_path(long_path, lock_path), SQLITE_ERROR);
+
+    unsetenv("PKCS11_SQL_LOCK");
+}
+
 int main(int argc, char* argv[]) {
     (void) argc;
     (void) argv;
@@ -2950,7 +2992,8 @@ int main(int argc, char* argv[]) {
         cmocka_unit_test(test_db_add_token_sqlite3_bind_text_3_fail),
         cmocka_unit_test(test_db_add_token_sqlite3_bind_blob_1_fail),
         cmocka_unit_test(test_db_add_token_sqlite3_bind_blob_2_fail),
-        cmocka_unit_test(test_db_add_token_sqlite3_step_2_fail)
+        cmocka_unit_test(test_db_add_token_sqlite3_step_2_fail),
+        cmocka_unit_test(test_db_get_lock_path),
     };
 
     return cmocka_run_group_tests(tests, NULL, NULL);
