From 37d9cdd4cb127563962df9f28124fb54c57f807f Mon Sep 17 00:00:00 2001
From: Jorge Ramirez-Ortiz <jorge@foundries.io>
Date: Mon, 2 Dec 2019 23:51:15 +0100
Subject: [PATCH] Foundries.IO Verified Boot Trusted Application

This code implements RPMB access to securely read/write a set of
values.

Currently the supported values are bootcount, m4hash and rollback.

Signed-off-by: Jorge Ramirez-Ortiz <jorge@foundries.io>
---
 ta/fiovb/Makefile                 |  18 +++
 ta/fiovb/entry.c                  | 187 ++++++++++++++++++++++++++++++
 ta/fiovb/include/ta_fiovb.h       |  29 +++++
 ta/fiovb/sub.mk                   |   3 +
 ta/fiovb/user_ta.mk               |   1 +
 ta/fiovb/user_ta_header_defines.h |  17 +++
 6 files changed, 255 insertions(+)
 create mode 100644 ta/fiovb/Makefile
 create mode 100644 ta/fiovb/entry.c
 create mode 100644 ta/fiovb/include/ta_fiovb.h
 create mode 100644 ta/fiovb/sub.mk
 create mode 100644 ta/fiovb/user_ta.mk
 create mode 100644 ta/fiovb/user_ta_header_defines.h

diff --git a/ta/fiovb/Makefile b/ta/fiovb/Makefile
new file mode 100644
index 00000000..cdc86806
--- /dev/null
+++ b/ta/fiovb/Makefile
@@ -0,0 +1,18 @@
+# The UUID for the Trusted Application
+BINARY=22250a54-0bf1-48fe-8002-7b20f1c9c9b1
+
+ifdef TA_CROSS_COMPILE
+CROSS_COMPILE ?= $(TA_CROSS_COMPILE)
+endif
+export CROSS_COMPILE
+
+CFG_TEE_TA_LOG_LEVEL ?= 2
+CPPFLAGS += -DCFG_TEE_TA_LOG_LEVEL=$(CFG_TEE_TA_LOG_LEVEL)
+
+-include $(TA_DEV_KIT_DIR)/mk/ta_dev_kit.mk
+
+ifeq ($(wildcard $(TA_DEV_KIT_DIR)/mk/ta_dev_kit.mk), )
+clean:
+	@echo 'Note: $$(TA_DEV_KIT_DIR)/mk/ta_dev_kit.mk not found, cannot clean TA'
+	@echo 'Note: TA_DEV_KIT_DIR=$(TA_DEV_KIT_DIR)'
+endif
diff --git a/ta/fiovb/entry.c b/ta/fiovb/entry.c
new file mode 100644
index 00000000..92263fe2
--- /dev/null
+++ b/ta/fiovb/entry.c
@@ -0,0 +1,187 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/* Copyright (c) 2018, Linaro Limited */
+/* Copyright (c) 2019, Foundries.IO */
+
+#include <ta_fiovb.h>
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+
+#include <string.h>
+#include <util.h>
+
+#define DEFAULT_LOCK_STATE	0
+
+static const uint32_t storageid = TEE_STORAGE_PRIVATE_RPMB;
+static const char *named_value_prefix = "named_value_";
+
+static TEE_Result get_named_object_name(char *name_orig,
+					uint32_t name_orig_size,
+					char *name, uint32_t *name_size)
+{
+	size_t pref_len = strlen(named_value_prefix);
+
+	if (name_orig_size + pref_len >
+	    TEE_OBJECT_ID_MAX_LEN)
+		return TEE_ERROR_BAD_PARAMETERS;
+
+	/* Start with prefix */
+	TEE_MemMove(name, named_value_prefix, pref_len);
+
+	/* Concatenate provided object name */
+	TEE_MemMove(name + pref_len, name_orig, name_orig_size);
+
+	*name_size = name_orig_size + pref_len;
+
+	return TEE_SUCCESS;
+}
+
+static TEE_Result check_valid_value(char *val)
+{
+	const char *valid_values[] = PERSIST_VALUE_LIST;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(valid_values); i++) {
+		if (strcmp(val, valid_values[i]) == 0)
+			return TEE_SUCCESS;
+	}
+
+	return TEE_ERROR_ITEM_NOT_FOUND;
+}
+
+static TEE_Result write_persist_value(uint32_t pt,
+				      TEE_Param params[TEE_NUM_PARAMS])
+{
+	const uint32_t exp_pt = TEE_PARAM_TYPES(TEE_PARAM_TYPE_MEMREF_INPUT,
+						TEE_PARAM_TYPE_MEMREF_INPUT,
+						TEE_PARAM_TYPE_NONE,
+						TEE_PARAM_TYPE_NONE);
+	const uint32_t flags = TEE_DATA_FLAG_ACCESS_READ |
+			       TEE_DATA_FLAG_ACCESS_WRITE |
+			       TEE_DATA_FLAG_OVERWRITE;
+	TEE_Result res;
+	TEE_ObjectHandle h;
+
+	char name_full[TEE_OBJECT_ID_MAX_LEN];
+	uint32_t name_full_sz;
+
+	if (pt != exp_pt)
+		return TEE_ERROR_BAD_PARAMETERS;
+
+	char *name_buf = params[0].memref.buffer;
+	uint32_t name_buf_sz = params[0].memref.size;
+
+	if (check_valid_value(name_buf) != TEE_SUCCESS) {
+		EMSG("Not found %s", name_buf);
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	char *value = params[1].memref.buffer;
+	uint32_t value_sz = params[1].memref.size;
+
+	res = get_named_object_name(name_buf, name_buf_sz,
+				    name_full, &name_full_sz);
+	if (res)
+		return res;
+
+	res = TEE_CreatePersistentObject(storageid, name_full,
+					 name_full_sz,
+					 flags, NULL, value,
+					 value_sz, &h);
+	if (res)
+		EMSG("Can't create named object value, res = 0x%x", res);
+
+	TEE_CloseObject(h);
+
+	return res;
+}
+
+static TEE_Result read_persist_value(uint32_t pt,
+				      TEE_Param params[TEE_NUM_PARAMS])
+{
+	const uint32_t exp_pt = TEE_PARAM_TYPES(TEE_PARAM_TYPE_MEMREF_INPUT,
+						TEE_PARAM_TYPE_MEMREF_INOUT,
+						TEE_PARAM_TYPE_NONE,
+						TEE_PARAM_TYPE_NONE);
+	uint32_t flags = TEE_DATA_FLAG_ACCESS_READ |
+			 TEE_DATA_FLAG_ACCESS_WRITE;
+	TEE_Result res;
+	TEE_ObjectHandle h;
+
+	char name_full[TEE_OBJECT_ID_MAX_LEN];
+	uint32_t name_full_sz;
+	uint32_t count;
+
+	if (pt != exp_pt)
+		return TEE_ERROR_BAD_PARAMETERS;
+
+	char *name_buf = params[0].memref.buffer;
+
+	if (check_valid_value(name_buf) != TEE_SUCCESS) {
+		EMSG("Not found %s", name_buf);
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	uint32_t name_buf_sz = params[0].memref.size;
+
+	char *value = params[1].memref.buffer;
+	uint32_t value_sz = params[1].memref.size;
+
+	res = get_named_object_name(name_buf, name_buf_sz,
+				    name_full, &name_full_sz);
+	if (res)
+		return res;
+
+	res = TEE_OpenPersistentObject(storageid, name_full,
+				       name_full_sz, flags, &h);
+	if (res) {
+		EMSG("Can't open named object value, res = 0x%x", res);
+		return res;
+	}
+
+	res =  TEE_ReadObjectData(h, value, value_sz, &count);
+	if (res) {
+		EMSG("Can't read named object value, res = 0x%x", res);
+		goto out;
+	}
+
+	params[1].memref.size = count;
+out:
+	TEE_CloseObject(h);
+
+	return res;
+}
+
+TEE_Result TA_CreateEntryPoint(void)
+{
+	return TEE_SUCCESS;
+}
+
+void TA_DestroyEntryPoint(void)
+{
+}
+
+TEE_Result TA_OpenSessionEntryPoint(uint32_t pt __unused,
+				    TEE_Param params[4] __unused,
+				    void **session __unused)
+{
+	return TEE_SUCCESS;
+}
+
+void TA_CloseSessionEntryPoint(void *sess __unused)
+{
+}
+
+TEE_Result TA_InvokeCommandEntryPoint(void *sess __unused, uint32_t cmd,
+				      uint32_t pt,
+				      TEE_Param params[TEE_NUM_PARAMS])
+{
+	switch (cmd) {
+	case TA_FIOVB_CMD_READ_PERSIST_VALUE:
+		return read_persist_value(pt, params);
+	case TA_FIOVB_CMD_WRITE_PERSIST_VALUE:
+		return write_persist_value(pt, params);
+	default:
+		EMSG("Command ID 0x%x is not supported", cmd);
+		return TEE_ERROR_NOT_SUPPORTED;
+	}
+}
diff --git a/ta/fiovb/include/ta_fiovb.h b/ta/fiovb/include/ta_fiovb.h
new file mode 100644
index 00000000..f401ce0e
--- /dev/null
+++ b/ta/fiovb/include/ta_fiovb.h
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/* Copyright (c) 2018, Linaro Limited */
+/* Copyright (c) 2019, Foundries.IO */
+
+#ifndef __TA_FIOVB_H
+#define __TA_FIOVB_H
+
+#define TA_FIOVB_UUID {0x22250a54, 0x0bf1, 0x48fe, \
+		      { 0x80, 0x02, 0x7b, 0x20, 0xf1, 0xc9, 0xc9, 0xb1 } }
+
+#define PERSIST_VALUE_LIST {"bootcount", "rollback", "m4hash", "m4size"}
+
+/*
+ * Reads a persistent value corresponding to the given name.
+ *
+ * in	params[0].memref:	persistent value name
+ * out	params[1].memref:	read persistent value buffer
+ */
+#define TA_FIOVB_CMD_READ_PERSIST_VALUE		0
+
+/*
+ * Writes a persistent value corresponding to the given name.
+ *
+ * in	params[0].memref:	persistent value name
+ * in	params[1].memref:	persistent value buffer to write
+ */
+#define TA_FIOVB_CMD_WRITE_PERSIST_VALUE	1
+
+#endif /*__TA_FIOVB_H*/
diff --git a/ta/fiovb/sub.mk b/ta/fiovb/sub.mk
new file mode 100644
index 00000000..f1b35c03
--- /dev/null
+++ b/ta/fiovb/sub.mk
@@ -0,0 +1,3 @@
+global-incdirs-y += include
+global-incdirs-y += .
+srcs-y += entry.c
diff --git a/ta/fiovb/user_ta.mk b/ta/fiovb/user_ta.mk
new file mode 100644
index 00000000..a8856582
--- /dev/null
+++ b/ta/fiovb/user_ta.mk
@@ -0,0 +1 @@
+user-ta-uuid := 22250a54-0bf1-48fe-8002-7b20f1c9c9b1
diff --git a/ta/fiovb/user_ta_header_defines.h b/ta/fiovb/user_ta_header_defines.h
new file mode 100644
index 00000000..9da77228
--- /dev/null
+++ b/ta/fiovb/user_ta_header_defines.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/* Copyright (c) 2019, Foundries.IO */
+
+#ifndef __USER_TA_HEADER_DEFINES_H
+#define __USER_TA_HEADER_DEFINES_H
+
+#include <ta_fiovb.h>
+
+#define TA_UUID				TA_FIOVB_UUID
+
+#define TA_FLAGS			(TA_FLAG_SINGLE_INSTANCE | \
+					 TA_FLAG_MULTI_SESSION)
+
+#define TA_STACK_SIZE			(16 * 1024)
+#define TA_DATA_SIZE			(16 * 1024)
+
+#endif /*__USER_TA_HEADER_DEFINES_H*/
-- 
2.17.1

