#!/bin/sh
# Copyright (c) Fathi Boudra <fathi.boudra@linaro.org>
# Copyright (c) 2019-2023 Foundries.IO
#
# All rights reserved.
#
# SPDX-License-Identifier: BSD-2-Clause

# must exit on error
set -e
set -o pipefail

# we must be root
[ $(whoami) = "root" ] || { echo "E: You must be root" && exit 1; }

# we must have few tools
SGDISK=$(which sgdisk) || { echo "E: You must have sgdisk" && exit 1; }
FDISK=$(which fdisk) || { echo "E: You must have fdisk" && exit 1; }
PARTX=$(which partx) || { echo "E: You must have partx" && exit 1; }
RESIZE2FS=$(which resize2fs) || { echo "E: You must have resize2fs" && exit 1; }

# find root device
ROOT_DEVICE=$(findmnt --noheadings --output=SOURCE / | cut -d'[' -f1)
# identify a possible mapper-based device (e.g. luks)
if echo ${ROOT_DEVICE} | grep -q "^/dev/mapper/"; then
	DM_NAME=`basename ${ROOT_DEVICE}`
fi
# prune root device (for example UUID)
ROOT_DEVICE=$(realpath ${ROOT_DEVICE})
# check if root device is available via device-mapper / luks
if [ -n "${DM_NAME}" ]; then
	ROOT_DEVICE="/dev/`dmsetup deps -o devname ${ROOT_DEVICE} | cut -d'(' -f2 | cut -d')' -f1`"
fi
# get the partition number and type
INFO=$(udevadm info --query=property --name=${ROOT_DEVICE})
PART_ENTRY_NUMBER=$(echo "${INFO}" | grep '^ID_PART_ENTRY_NUMBER=' | cut -d'=' -f2)

# in case the root device is not on a partitioned media
if [ "x$PART_ENTRY_NUMBER" = "x" ]; then
	${RESIZE2FS} "${ROOT_DEVICE}"
	exit 0
fi

PART_TABLE_TYPE=$(echo "${INFO}" | grep '^ID_PART_TABLE_TYPE=' | cut -d'=' -f2)
# find the block device
DEVICE=$(udevadm info --query=path --name=${ROOT_DEVICE} | awk -F'/' '{print $(NF-1)}')
DEVICE="/dev/${DEVICE}"

# only manipulate the last partition from the same disk used by the rootfs
LAST_PART=$(partx -s -o nr ${DEVICE} | tail -n1 | awk -F' ' '{print $1}')
RESIZE_PART="${DEVICE}${LAST_PART}"
INFO=$(udevadm info --query=property --name=${RESIZE_PART})
PART_ENTRY_NUMBER=$(echo "${INFO}" | grep '^ID_PART_ENTRY_NUMBER=' | cut -d'=' -f2)
PART_ENTRY_NAME=$(echo "${INFO}" | { grep '^ID_PART_ENTRY_NAME=' || true; } | cut -d'=' -f2)

# resize the partition first and after the actual file system
SIZE=$(blockdev --getsz ${DEVICE})
TYPE="p\n"
if [ "$PART_TABLE_TYPE" = "gpt" ]; then
	${SGDISK} -e ${DEVICE}
	SIZE=$(($SIZE - 33)) # the GPT end of disk is 34 sectors
	TYPE=""
fi
# Use fdisk to repartition
# fdisk uses a ram image of the parition table until a write is performed
# so the sequence is to delete the partition and recreate it at the same
# starting point but making it the size of the available disk.
#
END=$((${SIZE} - 1))
PARTOF=$(echo "${INFO}" | grep '^ID_PART_ENTRY_OFFSET=' | cut -d'=' -f2)
echo -e "d\n${PART_ENTRY_NUMBER}\nn\n${TYPE}${PART_ENTRY_NUMBER}\n${PARTOF}\n${END}\nw\n" | ${FDISK} ${DEVICE}
if [ -n "${PART_ENTRY_NAME}" ]; then
	${SGDISK} --change-name=${PART_ENTRY_NUMBER}:"${PART_ENTRY_NAME}" ${DEVICE}
fi
${PARTX} -u ${DEVICE}

if command -v cryptsetup > /dev/null && cryptsetup isLuks ${RESIZE_PART}; then
	# OP-TEE: use TEE Identity for pkcs11 authentication
	export CKTEEC_LOGIN_TYPE=user
	DM_NAME=`lsblk -n --list -o NAME,TYPE ${RESIZE_PART} | awk '$2=="crypt" {print $1}'`
	cryptsetup resize --token-only ${DM_NAME}
	${RESIZE2FS} "/dev/mapper/${DM_NAME}"
else
	${RESIZE2FS} "${RESIZE_PART}"
fi
