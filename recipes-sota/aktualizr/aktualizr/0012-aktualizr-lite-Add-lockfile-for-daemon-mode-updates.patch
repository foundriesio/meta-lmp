From c08492585dfb266a7b29caf388403ffc03d3c591 Mon Sep 17 00:00:00 2001
From: Andy Doan <andy@foundries.io>
Date: Wed, 3 Jul 2019 23:36:27 -0500
Subject: [PATCH 12/12] aktualizr-lite: Add lockfile for daemon mode updates

This allows a different process to block the aktualizr-lite daemon
from doing updates (and the reboot) if its doing something important.

Signed-off-by: Andy Doan <andy@foundries.io>
---
 src/aktualizr_lite/main.cc | 35 ++++++++++++++++++++++++++++++++---
 1 file changed, 32 insertions(+), 3 deletions(-)

diff --git a/src/aktualizr_lite/main.cc b/src/aktualizr_lite/main.cc
index b7fcb56b..63e963ea 100644
--- a/src/aktualizr_lite/main.cc
+++ b/src/aktualizr_lite/main.cc
@@ -1,3 +1,4 @@
+#include <sys/file.h>
 #include <unistd.h>
 #include <iostream>
 
@@ -219,13 +220,32 @@ static std::unique_ptr<Uptane::Target> find_target(const std::shared_ptr<SotaUpt
   throw std::runtime_error("Unable to find update");
 }
 
-static int do_update(SotaUptaneClient &client, INvStorage &storage, Uptane::Target &target) {
+static int get_lock(const char *lockfile) {
+  int fd = open(lockfile, O_RDWR | O_CREAT | O_APPEND, 0666);
+  if (fd < 0) {
+    LOG_ERROR << "Unable to open lock file";
+    return -1;
+  }
+  LOG_INFO << "Aquiring lock";
+  if (flock(fd, LOCK_EX) < 0) {
+    LOG_ERROR << "Unable to aquire lock";
+    close(fd);
+    return -1;
+  }
+  return fd;
+}
+
+static int do_update(SotaUptaneClient &client, INvStorage &storage, Uptane::Target &target, const char *lockfile) {
   if (!client.downloadImage(target).first) {
     return 1;
   }
 
   if (client.VerifyTarget(target) != TargetStatus::kGood) {
     LOG_ERROR << "Downloaded target is invalid";
+  }
+
+  int lockfd = 0;
+  if (lockfile != nullptr && (lockfd = get_lock(lockfile)) < 0) {
     return 1;
   }
 
@@ -237,6 +257,8 @@ static int do_update(SotaUptaneClient &client, INvStorage &storage, Uptane::Targ
     storage.saveInstalledVersion("", target, InstalledVersionUpdateMode::kCurrent);
   } else {
     LOG_ERROR << "Unable to install update: " << iresult.description;
+    // let go of the lock since we couldn't update
+    close(lockfd);
     return 1;
   }
   LOG_INFO << iresult.description;
@@ -259,7 +281,7 @@ static int update_main(Config &config, const bpo::variables_map &variables_map)
     return 0;
   }
   LOG_INFO << "Updating to: " << *target;
-  return do_update(*client, *storage, *target);
+  return do_update(*client, *storage, *target, nullptr);
 }
 
 static int daemon_main(Config &config, const bpo::variables_map &variables_map) {
@@ -267,6 +289,12 @@ static int daemon_main(Config &config, const bpo::variables_map &variables_map)
     LOG_ERROR << "reboot command: " << config.bootloader.reboot_command << " is not executable";
     return 1;
   }
+  const char *lockfile = nullptr;
+  boost::filesystem::path lockfilePath;
+  if (variables_map.count("update-lockfile") > 0) {
+    lockfilePath = variables_map["update-lockfile"].as<boost::filesystem::path>();
+    lockfile = lockfilePath.c_str();
+  }
 
   auto storage = INvStorage::newStorage(config.storage);
   auto client = liteClient(config, storage);
@@ -289,7 +317,7 @@ static int daemon_main(Config &config, const bpo::variables_map &variables_map)
     auto target = find_target(client, hwid, config.pacman.tags, "latest");
     if (target != nullptr && !targets_eq(*target, current, compareDockerApps)) {
       LOG_INFO << "Updating base image to: " << *target;
-      if (do_update(*client, *storage, *target) == 0) {
+      if (do_update(*client, *storage, *target, lockfile) == 0) {
         if (std::system(config.bootloader.reboot_command.c_str()) != 0) {
           LOG_ERROR << "Unable to reboot system";
           return 1;
@@ -345,6 +373,7 @@ bpo::variables_map parse_options(int argc, char *argv[]) {
       ("primary-ecu-hardware-id", bpo::value<std::string>(), "hardware ID of primary ecu")
       ("update-name", bpo::value<std::string>(), "optional name of the update when running \"update\". default=latest")
       ("interval", bpo::value<unsigned int>(), "optional interval in seconds to poll for update when in daemon mode. default=300")
+      ("update-lockfile", bpo::value<boost::filesystem::path>(), "If provided, an flock(2) is applied to this file before performing an update in daemon mode")
       ("command", bpo::value<std::string>(), subs.c_str());
   // clang-format on
 
-- 
2.23.0

