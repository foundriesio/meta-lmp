From 0bcfc37f2041c1914a6f34c3597c6aad9e0dc748 Mon Sep 17 00:00:00 2001
From: Andy Doan <andy@foundries.io>
Date: Wed, 3 Jul 2019 23:36:27 -0500
Subject: [PATCH 8/8] aktualizr-lite: Add lockfile for daemon mode updates

This allows a different process to block the aktualizr-lite daemon
from doing updates (and the reboot) if its doing something important.

Signed-off-by: Andy Doan <andy@foundries.io>
---
 src/aktualizr_lite/main.cc | 37 ++++++++++++++++++++++++++++++++++---
 1 file changed, 34 insertions(+), 3 deletions(-)

diff --git a/src/aktualizr_lite/main.cc b/src/aktualizr_lite/main.cc
index afe81165..903bae18 100644
--- a/src/aktualizr_lite/main.cc
+++ b/src/aktualizr_lite/main.cc
@@ -1,3 +1,4 @@
+#include <sys/file.h>
 #include <unistd.h>
 #include <iostream>
 
@@ -219,12 +220,33 @@ static std::unique_ptr<Uptane::Target> find_target(const std::shared_ptr<SotaUpt
   throw std::runtime_error("Unable to find update");
 }
 
-static int do_update(SotaUptaneClient &client, INvStorage &storage, Uptane::Target &target) {
+static int get_lock(const char *lockfile) {
+  int fd = open(lockfile, O_RDWR | O_CREAT | O_APPEND, 0666);
+  if (fd < 0) {
+    LOG_ERROR << "Unable to open lock file";
+    return -1;
+  }
+  LOG_INFO << "Aquiring lock";
+  if (flock(fd, LOCK_EX) < 0) {
+    LOG_ERROR << "Unable to aquire lock";
+    close(fd);
+    return -1;
+  }
+  return fd;
+}
+
+static int do_update(SotaUptaneClient &client, INvStorage &storage, Uptane::Target &target, const char *lockfile) {
   if (!client.downloadImage(target).first) {
     return 1;
   }
 
   // TODO make pacman->verifyTarget something we can get to via client->
+
+  int lockfd = 0;
+  if (lockfile != nullptr && (lockfd = get_lock(lockfile)) < 0) {
+    return 1;
+  }
+
   auto iresult = client.PackageInstall(target);
   if (iresult.result_code.num_code == data::ResultCode::Numeric::kNeedCompletion) {
     LOG_INFO << "Update complete. Please reboot the device to activate";
@@ -233,6 +255,8 @@ static int do_update(SotaUptaneClient &client, INvStorage &storage, Uptane::Targ
     storage.saveInstalledVersion("", target, InstalledVersionUpdateMode::kCurrent);
   } else {
     LOG_ERROR << "Unable to install update: " << iresult.description;
+    // let go of the lock since we couldn't update
+    close(lockfd);
     return 1;
   }
   LOG_INFO << iresult.description;
@@ -255,7 +279,7 @@ static int update_main(Config &config, const bpo::variables_map &variables_map)
     return 0;
   }
   LOG_INFO << "Updating to: " << *target;
-  return do_update(*client, *storage, *target);
+  return do_update(*client, *storage, *target, nullptr);
 }
 
 static int daemon_main(Config &config, const bpo::variables_map &variables_map) {
@@ -263,6 +287,12 @@ static int daemon_main(Config &config, const bpo::variables_map &variables_map)
     LOG_ERROR << "reboot command: " << config.bootloader.reboot_command << " is not executable";
     return 1;
   }
+  const char *lockfile = nullptr;
+  boost::filesystem::path lockfilePath;
+  if (variables_map.count("update-lockfile") > 0) {
+    lockfilePath = variables_map["update-lockfile"].as<boost::filesystem::path>();
+    lockfile = lockfilePath.c_str();
+  }
 
   auto storage = INvStorage::newStorage(config.storage);
   auto client = liteClient(config, storage);
@@ -285,7 +315,7 @@ static int daemon_main(Config &config, const bpo::variables_map &variables_map)
     auto target = find_target(client, hwid, config.pacman.tags, "latest");
     if (target != nullptr && !targets_eq(*target, current, compareDockerApps)) {
       LOG_INFO << "Updating base image to: " << *target;
-      if (do_update(*client, *storage, *target) == 0) {
+      if (do_update(*client, *storage, *target, lockfile) == 0) {
         if (std::system(config.bootloader.reboot_command.c_str()) != 0) {
           LOG_ERROR << "Unable to reboot system";
           return 1;
@@ -342,6 +372,7 @@ bpo::variables_map parse_options(int argc, char *argv[]) {
       ("update-name", bpo::value<std::string>(), "optional name of the update when running \"update\". default=latest")
       ("interval", bpo::value<unsigned int>(), "optional interval in seconds to poll for update when in daemon mode. default=300")
       ("reboot-command", bpo::value<std::string>(), "reboot command to call after an update is applied from daemon mode")
+      ("update-lockfile", bpo::value<boost::filesystem::path>(), "If provided, an flock(2) is applied to this file before performing an update in daemon mode")
       ("command", bpo::value<std::string>(), subs.c_str());
   // clang-format on
 
-- 
2.23.0

