From a6a358a81096f0375f6896e6fe5f4410a5ce5d6c Mon Sep 17 00:00:00 2001
From: Andy Doan <andy@foundries.io>
Date: Fri, 28 Jun 2019 09:36:22 -0500
Subject: [PATCH 07/12] config: Add notion of "tags" to package manager

The idea here is that the aktualizr lite client can look at tags
in each target to decide if its applicable to for the device. This
would allow us to use one TUF repo to support things like premerge
and release builds.

Signed-off-by: Andy Doan <andy@foundries.io>
---
 src/aktualizr_lite/CMakeLists.txt             |  4 +--
 src/aktualizr_lite/helpers.cc                 | 15 +++++++++
 src/aktualizr_lite/helpers.h                  |  9 ++++++
 src/aktualizr_lite/helpers_test.cc            | 31 +++++++++++++++++++
 src/aktualizr_lite/main.cc                    | 15 +++++++--
 src/aktualizr_lite/test_lite.sh               | 15 ++++++---
 .../package_manager/packagemanagerconfig.cc   |  7 ++++-
 .../package_manager/packagemanagerconfig.h    |  1 +
 8 files changed, 87 insertions(+), 10 deletions(-)
 create mode 100644 src/aktualizr_lite/helpers.cc

diff --git a/src/aktualizr_lite/CMakeLists.txt b/src/aktualizr_lite/CMakeLists.txt
index f6f42375..7fb93a26 100644
--- a/src/aktualizr_lite/CMakeLists.txt
+++ b/src/aktualizr_lite/CMakeLists.txt
@@ -1,4 +1,4 @@
-set(AKTUALIZR_LITE_SRC main.cc)
+set(AKTUALIZR_LITE_SRC main.cc helpers.cc)
 set(AKTUALIZR_LITE_HEADERS helpers.h)
 
 if(BUILD_OSTREE)
@@ -22,7 +22,7 @@ add_library(t_lite-mock SHARED ostree_mock.cc)
 
 endif(BUILD_OSTREE)
 
-add_aktualizr_test(NAME lite-helpers SOURCES helpers_test.cc)
+add_aktualizr_test(NAME lite-helpers SOURCES helpers.cc helpers_test.cc)
 
 aktualizr_source_file_checks(main.cc ${AKTUALIZR_LITE_SRC} ${AKTUALIZR_LITE_HEADERS} helpers_test.cc ostree_mock.cc)
 # vim: set tabstop=4 shiftwidth=4 expandtab:
diff --git a/src/aktualizr_lite/helpers.cc b/src/aktualizr_lite/helpers.cc
new file mode 100644
index 00000000..e14293d3
--- /dev/null
+++ b/src/aktualizr_lite/helpers.cc
@@ -0,0 +1,15 @@
+#include "helpers.h"
+
+bool target_has_tags(const Uptane::Target& t, const std::vector<std::string>& config_tags) {
+  if (!config_tags.empty()) {
+    auto tags = t.custom_data()["tags"];
+    for (Json::ValueIterator i = tags.begin(); i != tags.end(); ++i) {
+      auto tag = (*i).asString();
+      if (std::find(config_tags.begin(), config_tags.end(), tag) != config_tags.end()) {
+        return true;
+      }
+    }
+    return false;
+  }
+  return true;
+}
diff --git a/src/aktualizr_lite/helpers.h b/src/aktualizr_lite/helpers.h
index 6c643e8a..81a9d8f9 100644
--- a/src/aktualizr_lite/helpers.h
+++ b/src/aktualizr_lite/helpers.h
@@ -1,10 +1,19 @@
+#ifndef AKTUALIZR_LITE_HELPERS
+#define AKTUALIZR_LITE_HELPERS
+
 #include <string>
 
 #include <string.h>
 
+#include "uptane/tuf.h"
+
 struct Version {
   std::string raw_ver;
   Version(std::string version) : raw_ver(std::move(version)) {}
 
   bool operator<(const Version& other) { return strverscmp(raw_ver.c_str(), other.raw_ver.c_str()) < 0; }
 };
+
+bool target_has_tags(const Uptane::Target& t, const std::vector<std::string>& config_tags);
+
+#endif  // AKTUALIZR_LITE_HELPERS
diff --git a/src/aktualizr_lite/helpers_test.cc b/src/aktualizr_lite/helpers_test.cc
index 96020ec7..c5fea698 100644
--- a/src/aktualizr_lite/helpers_test.cc
+++ b/src/aktualizr_lite/helpers_test.cc
@@ -19,6 +19,37 @@ TEST(version, good_versions) {
   ASSERT_TRUE(Version("1.9.0") < Version("1.10"));
 }
 
+TEST(version, target_has_tags) {
+  auto t = Uptane::Target::Unknown();
+
+  // No tags defined in target:
+  std::vector<std::string> config_tags;
+  ASSERT_TRUE(target_has_tags(t, config_tags));
+  config_tags.push_back("foo");
+  ASSERT_FALSE(target_has_tags(t, config_tags));
+
+  // Set target tags to: premerge, qa
+  auto custom = t.custom_data();
+  custom["tags"].append("premerge");
+  custom["tags"].append("qa");
+  t.updateCustom(custom);
+
+  config_tags.clear();
+  ASSERT_TRUE(target_has_tags(t, config_tags));
+
+  config_tags.push_back("qa");
+  config_tags.push_back("blah");
+  ASSERT_TRUE(target_has_tags(t, config_tags));
+
+  config_tags.clear();
+  config_tags.push_back("premerge");
+  ASSERT_TRUE(target_has_tags(t, config_tags));
+
+  config_tags.clear();
+  config_tags.push_back("foo");
+  ASSERT_FALSE(target_has_tags(t, config_tags));
+}
+
 #ifndef __NO_MAIN__
 int main(int argc, char **argv) {
   ::testing::InitGoogleTest(&argc, argv);
diff --git a/src/aktualizr_lite/main.cc b/src/aktualizr_lite/main.cc
index 868814d5..4751a7ca 100644
--- a/src/aktualizr_lite/main.cc
+++ b/src/aktualizr_lite/main.cc
@@ -125,6 +125,9 @@ static int list_main(Config &config, const bpo::variables_map &unused) {
 
   LOG_INFO << "Updates available to " << hwid << ":";
   for (auto &t : client->allTargets()) {
+    if (!target_has_tags(t, config.pacman.tags)) {
+      continue;
+    }
     for (auto const &it : t.hardwareIds()) {
       if (it == hwid) {
         log_info_target("", config, t);
@@ -136,7 +139,8 @@ static int list_main(Config &config, const bpo::variables_map &unused) {
 }
 
 static std::unique_ptr<Uptane::Target> find_target(const std::shared_ptr<SotaUptaneClient> &client,
-                                                   Uptane::HardwareIdentifier &hwid, const std::string &version) {
+                                                   Uptane::HardwareIdentifier &hwid,
+                                                   const std::vector<std::string> &tags, const std::string &version) {
   std::unique_ptr<Uptane::Target> rv;
   if (!client->updateImagesMeta()) {
     LOG_WARNING << "Unable to update latest metadata, using local copy";
@@ -149,6 +153,9 @@ static std::unique_ptr<Uptane::Target> find_target(const std::shared_ptr<SotaUpt
   bool find_latest = (version == "latest");
   std::unique_ptr<Uptane::Target> latest = nullptr;
   for (auto &t : client->allTargets()) {
+    if (!target_has_tags(t, tags)) {
+      continue;
+    }
     for (auto const &it : t.hardwareIds()) {
       if (it == hwid) {
         if (find_latest) {
@@ -201,7 +208,11 @@ static int update_main(Config &config, const bpo::variables_map &variables_map)
     version = variables_map["update-name"].as<std::string>();
   }
   LOG_INFO << "Finding " << version << " to update to...";
-  auto target = find_target(client, hwid, version);
+  auto target = find_target(client, hwid, config.pacman.tags, version);
+  if (target == nullptr) {
+    LOG_INFO << "Already up-to-date";
+    return 0;
+  }
   LOG_INFO << "Updating to: " << *target;
   return do_update(*client, *storage, *target);
 }
diff --git a/src/aktualizr_lite/test_lite.sh b/src/aktualizr_lite/test_lite.sh
index ccdeafa1..d2b17423 100755
--- a/src/aktualizr_lite/test_lite.sh
+++ b/src/aktualizr_lite/test_lite.sh
@@ -70,16 +70,16 @@ repo_server = "http://localhost:$port/repo/repo"
 [provision]
 primary_ecu_hardware_id = "hwid-for-test"
 
-[pacman]
-type = "ostree"
-sysroot = "$OSTREE_SYSROOT"
-os = "dummy-os"
-
 [storage]
 type = "sqlite"
 path = "$sota_dir"
 sqldb_path = "sql.db"
 uptane_metadata_path = "$sota_dir/metadata"
+
+[pacman]
+type = "ostree"
+sysroot = "$OSTREE_SYSROOT"
+os = "dummy-os"
 EOF
 
 ## Check that we can do the info command
@@ -114,3 +114,8 @@ if [[ ! "$out" =~ "Active image is: zlast	sha256:$sha" ]] ; then
     echo $out
     exit 1
 fi
+
+## Make sure we obey tags
+echo 'tags = "promoted"' >> $sota_dir/sota.toml
+cd /tmp/
+OSTREE_HASH=$sha LD_PRELOAD=$mock_ostree $valgrind $aklite --loglevel 1 -c $sota_dir/sota.toml update | grep "Already up-to-date"
diff --git a/src/libaktualizr/package_manager/packagemanagerconfig.cc b/src/libaktualizr/package_manager/packagemanagerconfig.cc
index 53677bd8..c36ef082 100644
--- a/src/libaktualizr/package_manager/packagemanagerconfig.cc
+++ b/src/libaktualizr/package_manager/packagemanagerconfig.cc
@@ -33,8 +33,12 @@ void PackageConfig::updateFromPropertyTree(const boost::property_tree::ptree& pt
   CopyFromConfig(ostree_server, "ostree_server", pt);
   CopyFromConfig(packages_file, "packages_file", pt);
   CopyFromConfig(fake_need_reboot, "fake_need_reboot", pt);
-#ifdef BUILD_DOCKERAPP
   std::string val;
+  CopyFromConfig(val, "tags", pt);
+  if (val.length() > 0) {
+    boost::split(tags, val, boost::is_any_of(", "), boost::token_compress_on);
+  }
+#ifdef BUILD_DOCKERAPP
   CopyFromConfig(val, "docker_apps", pt);
   if (val.length() > 0) {
     // token_compress_on allows lists like: "foo,bar", "foo, bar", or "foo bar"
@@ -54,6 +58,7 @@ void PackageConfig::writeToStream(std::ostream& out_stream) const {
   writeOption(out_stream, ostree_server, "ostree_server");
   writeOption(out_stream, packages_file, "packages_file");
   writeOption(out_stream, fake_need_reboot, "fake_need_reboot");
+  writeOption(out_stream, boost::algorithm::join(tags, ","), "tags");
 #ifdef BUILD_DOCKERAPP
   writeOption(out_stream, boost::algorithm::join(docker_apps, ","), "docker_apps");
   writeOption(out_stream, docker_apps_root, "docker_apps_root");
diff --git a/src/libaktualizr/package_manager/packagemanagerconfig.h b/src/libaktualizr/package_manager/packagemanagerconfig.h
index d19bdd87..f0f3c9a1 100644
--- a/src/libaktualizr/package_manager/packagemanagerconfig.h
+++ b/src/libaktualizr/package_manager/packagemanagerconfig.h
@@ -16,6 +16,7 @@ struct PackageConfig {
   boost::filesystem::path sysroot;
   std::string ostree_server;
   boost::filesystem::path packages_file{"/usr/package.manifest"};
+  std::vector<std::string> tags;
 
 #ifdef BUILD_DOCKERAPP
   std::vector<std::string> docker_apps;
-- 
2.23.0

