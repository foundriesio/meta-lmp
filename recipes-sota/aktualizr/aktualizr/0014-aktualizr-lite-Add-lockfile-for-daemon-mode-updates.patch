From ae6ec43ec08f55471e8f117947a89ede89f6f22b Mon Sep 17 00:00:00 2001
From: Andy Doan <andy@foundries.io>
Date: Wed, 3 Jul 2019 23:36:27 -0500
Subject: [PATCH 14/14] aktualizr-lite: Add lockfile for daemon mode updates

This allows a different process to block the aktualizr-lite daemon
from doing updates (and the reboot) if its doing something important.

Signed-off-by: Andy Doan <andy@foundries.io>
---
 src/aktualizr_lite/main.cc | 36 +++++++++++++++++++++++++++++++++---
 1 file changed, 33 insertions(+), 3 deletions(-)

diff --git a/src/aktualizr_lite/main.cc b/src/aktualizr_lite/main.cc
index 06a50a7b..7294f9d2 100644
--- a/src/aktualizr_lite/main.cc
+++ b/src/aktualizr_lite/main.cc
@@ -1,3 +1,4 @@
+#include <sys/file.h>
 #include <unistd.h>
 #include <iostream>
 
@@ -214,7 +215,22 @@ static std::unique_ptr<Uptane::Target> find_target(const std::shared_ptr<SotaUpt
   throw std::runtime_error("Unable to find update");
 }
 
-static int do_update(SotaUptaneClient &client, INvStorage &storage, Uptane::Target &target) {
+static int get_lock(const char *lockfile) {
+  int fd = open(lockfile, O_RDWR | O_CREAT | O_APPEND, 0666);
+  if (fd < 0) {
+    LOG_ERROR << "Unable to open lock file";
+    return -1;
+  }
+  LOG_INFO << "Aquiring lock";
+  if (flock(fd, LOCK_EX) < 0) {
+    LOG_ERROR << "Unable to aquire lock";
+    close(fd);
+    return -1;
+  }
+  return fd;
+}
+
+static int do_update(SotaUptaneClient &client, INvStorage &storage, Uptane::Target &target, const char *lockfile) {
   std::vector<Uptane::Target> targets{target};
   auto result = client.downloadImages(targets);
   if (result.status != result::DownloadStatus::kSuccess &&
@@ -223,6 +239,11 @@ static int do_update(SotaUptaneClient &client, INvStorage &storage, Uptane::Targ
     return 1;
   }
 
+  int lockfd = 0;
+  if (lockfile != nullptr && (lockfd = get_lock(lockfile)) < 0) {
+    return 1;
+  }
+
   auto iresult = client.PackageInstall(target);
   if (iresult.result_code.num_code == data::ResultCode::Numeric::kNeedCompletion) {
     LOG_INFO << "Update complete. Please reboot the device to activate";
@@ -231,6 +252,8 @@ static int do_update(SotaUptaneClient &client, INvStorage &storage, Uptane::Targ
     storage.saveInstalledVersion("", target, InstalledVersionUpdateMode::kCurrent);
   } else {
     LOG_ERROR << "Unable to install update: " << iresult.description;
+    // let go of the lock since we couldn't update
+    close(lockfd);
     return 1;
   }
   LOG_INFO << iresult.description;
@@ -253,7 +276,7 @@ static int update_main(Config &config, const bpo::variables_map &variables_map)
     return 0;
   }
   LOG_INFO << "Updating to: " << *target;
-  return do_update(*client, *storage, *target);
+  return do_update(*client, *storage, *target, nullptr);
 }
 
 static int daemon_main(Config &config, const bpo::variables_map &variables_map) {
@@ -262,6 +285,12 @@ static int daemon_main(Config &config, const bpo::variables_map &variables_map)
     LOG_ERROR << "reboot command: " << rebootCmd << " is not executable";
     return 1;
   }
+  const char *lockfile = nullptr;
+  boost::filesystem::path lockfilePath;
+  if (variables_map.count("update-lockfile") > 0) {
+    lockfilePath = variables_map["update-lockfile"].as<boost::filesystem::path>();
+    lockfile = lockfilePath.c_str();
+  }
 
   auto storage = INvStorage::newStorage(config.storage);
   auto client = liteClient(config, storage);
@@ -284,7 +313,7 @@ static int daemon_main(Config &config, const bpo::variables_map &variables_map)
     auto target = find_target(client, hwid, config.pacman.tags, "latest");
     if (target != nullptr && !targets_eq(*target, current, compareDockerApps)) {
       LOG_INFO << "Updating base image to: " << *target;
-      if (do_update(*client, *storage, *target) == 0) {
+      if (do_update(*client, *storage, *target, lockfile) == 0) {
         if (std::system(rebootCmd.c_str()) != 0) {
           LOG_ERROR << "Unable to reboot system";
           return 1;
@@ -346,6 +375,7 @@ bpo::variables_map parse_options(int argc, char *argv[]) {
       ("update-name", bpo::value<std::string>(), "optional name of the update when running \"update\". default=latest")
       ("interval", bpo::value<unsigned int>(), "optional interval in seconds to poll for update when in daemon mode. default=300")
       ("reboot-command", bpo::value<boost::filesystem::path>(), "reboot command to call after an update is applied from daemon mode")
+      ("update-lockfile", bpo::value<boost::filesystem::path>(), "If provided, an flock(2) is applied to this file before performing an update in daemon mode")
       ("command", bpo::value<std::string>(), subs.c_str());
   // clang-format on
 
-- 
2.23.0

