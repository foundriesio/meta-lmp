From fa9aaf082327709b2acfcae18358fac482834571 Mon Sep 17 00:00:00 2001
From: Igor Opaniuk <igor.opaniuk@foundries.io>
Date: Thu, 23 Jun 2022 15:30:12 +0300
Subject: [PATCH] stm32mp1: save boot auth status and partition info

Introduce a functionality for saving/restoring boot auth status and
partition used for booting (FSBL partition on which the boot was successful).

Upstream-Status: Pending
Signed-off-by: Igor Opaniuk <igor.opaniuk@foundries.io>
---
 plat/st/stm32mp1/bl2_plat_setup.c           |  7 ++++
 plat/st/stm32mp1/include/stm32mp1_private.h |  2 ++
 plat/st/stm32mp1/stm32mp1_private.c         | 38 +++++++++++++++++++++
 3 files changed, 47 insertions(+)

diff --git a/plat/st/stm32mp1/bl2_plat_setup.c b/plat/st/stm32mp1/bl2_plat_setup.c
index 642138a1d..45fd00630 100644
--- a/plat/st/stm32mp1/bl2_plat_setup.c
+++ b/plat/st/stm32mp1/bl2_plat_setup.c
@@ -499,6 +499,13 @@ skip_console_init:
 		ERROR("Cannot save boot interface\n");
 	}
 
+	if (stm32_save_boot_auth(boot_context->auth_status,
+				 boot_context->boot_partition_used_toboot) !=
+
+	    0) {
+		ERROR("Cannot save boot authentication status\n");
+	}
+
 	stm32mp1_arch_security_setup();
 
 	print_reset_reason();
diff --git a/plat/st/stm32mp1/include/stm32mp1_private.h b/plat/st/stm32mp1/include/stm32mp1_private.h
index cbcd2c8bd..9d6ca83f4 100644
--- a/plat/st/stm32mp1/include/stm32mp1_private.h
+++ b/plat/st/stm32mp1/include/stm32mp1_private.h
@@ -31,6 +31,8 @@ bool stm32mp1_is_wakeup_from_standby(void);
 
 int stm32_save_boot_interface(uint32_t interface, uint32_t instance);
 int stm32_get_boot_interface(uint32_t *interface, uint32_t *instance);
+int stm32_save_boot_auth(uint32_t auth_status, uint32_t boot_partition);
+int stm32_get_boot_auth(uint32_t *auth_status, uint32_t *boot_partition);
 bool stm32_boot_is_serial(void);
 
 enum etzpc_decprot_attributes stm32mp_etzpc_binding2decprot(uint32_t mode);
diff --git a/plat/st/stm32mp1/stm32mp1_private.c b/plat/st/stm32mp1/stm32mp1_private.c
index 0451efe72..c419a2478 100644
--- a/plat/st/stm32mp1/stm32mp1_private.c
+++ b/plat/st/stm32mp1/stm32mp1_private.c
@@ -45,6 +45,8 @@
 #define TAMP_BOOT_ITF_BACKUP_REG_ID	U(20)
 #define TAMP_BOOT_ITF_MASK		U(0x0000FF00)
 #define TAMP_BOOT_ITF_SHIFT		8
+#define TAMP_BOOT_AUTH_MASK		U(0x000000FF)
+#define TAMP_BOOT_AUTH_SHIFT		0
 
 #if defined(IMAGE_BL2)
 #define MAP_SEC_SYSRAM	MAP_REGION_FLAT(STM32MP_SYSRAM_BASE, \
@@ -781,6 +783,42 @@ int stm32_get_boot_interface(uint32_t *interface, uint32_t *instance)
 	return 0;
 }
 
+int stm32_save_boot_auth(uint32_t auth_status, uint32_t boot_partition)
+{
+	uint32_t bkpr_itf_idx = tamp_bkpr(TAMP_BOOT_ITF_BACKUP_REG_ID);
+
+	clk_enable(RTCAPB);
+
+	mmio_clrsetbits_32(bkpr_itf_idx,
+			   TAMP_BOOT_AUTH_MASK,
+			   ((auth_status << 4) | (boot_partition & 0xFU)) <<
+			   TAMP_BOOT_AUTH_SHIFT);
+
+	clk_disable(RTCAPB);
+
+	return 0;
+}
+
+int stm32_get_boot_auth(uint32_t *auth_status, uint32_t *boot_partition)
+{
+	static uint32_t itf;
+
+	if (itf == 0U) {
+		uint32_t bkpr = tamp_bkpr(TAMP_BOOT_ITF_BACKUP_REG_ID);
+
+		clk_enable(RTCAPB);
+
+		itf = (mmio_read_32(bkpr) & TAMP_BOOT_AUTH_MASK) >> TAMP_BOOT_AUTH_SHIFT;
+
+		clk_disable(RTCAPB);
+	}
+
+	*auth_status = itf >> 4;
+	*boot_partition = itf & 0xFU;
+
+	return 0;
+}
+
 bool stm32_boot_is_serial(void)
 {
 	uint32_t boot_itf;
